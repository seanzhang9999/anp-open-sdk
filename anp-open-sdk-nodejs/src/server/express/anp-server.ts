/**
 * Copyright 2024 ANP Open SDK Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 */

import express, { Application, Request, Response } from 'express';
import { Agent } from '../../runtime/core/agent';
import { AgentManager } from '../../runtime/core/agent-manager';
import { 
  createAuthMiddleware, 
  corsMiddleware, 
  requestLogMiddleware 
} from '../../servicepoint/middleware';
import { AuthVerifier } from '../../foundation/auth';
import { getGlobalConfig } from '../../foundation/config';
import { getLogger } from '../../foundation/utils';
import { DIDServiceHandler } from '../../servicepoint/handlers/did-service-handler';
import { DomainManager } from '../../foundation/domain';

const logger = getLogger('AnpServer');

export interface ServerConfig {
  host?: string;
  port?: number;
  enableCors?: boolean;
  enableAuth?: boolean;
  enableLogging?: boolean;
}

export class AnpServer {
  private app: Application;
  private server: any;
  private authVerifier: AuthVerifier;
  private config: ServerConfig;

  constructor(config: ServerConfig = {}) {
    this.config = {
      host: config.host || 'localhost',
      port: config.port || 9527,
      enableCors: config.enableCors ?? true,
      enableAuth: config.enableAuth ?? true,
      enableLogging: config.enableLogging ?? true,
      ...config
    };

    this.app = express();
    this.authVerifier = new AuthVerifier();
    
    this.setupMiddleware();
    this.setupRoutes();
    
    logger.info(`AnpServerÈÖçÁΩÆ: ${JSON.stringify(this.config)}`);
  }

  /**
   * ËÆæÁΩÆ‰∏≠Èó¥‰ª∂
   */
  private setupMiddleware(): void {
    // Âü∫Á°Ä‰∏≠Èó¥‰ª∂
    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: true }));

    // CORS‰∏≠Èó¥‰ª∂
    if (this.config.enableCors) {
      this.app.use(corsMiddleware());
    }

    // ËØ∑Ê±ÇÊó•Âøó‰∏≠Èó¥‰ª∂
    if (this.config.enableLogging) {
      this.app.use(requestLogMiddleware());
    }

    // ËÆ§ËØÅ‰∏≠Èó¥‰ª∂
    if (this.config.enableAuth) {
      const authMiddleware = createAuthMiddleware(this.authVerifier);
      this.app.use(authMiddleware.middleware());
    }
  }

  /**
   * ËÆæÁΩÆË∑ØÁî±
   */
  private setupRoutes(): void {
    // DIDÊúçÂä°Ë∑ØÁî± - ÂøÖÈ°ªÂú®ËÆ§ËØÅ‰∏≠Èó¥‰ª∂‰πãÂâçÊàñËÄÖË±ÅÂÖçËÆ§ËØÅ
    this.setupDIDRoutes();

    // Ê∑ªÂä†Ë∑ØÁî±Ë∞ÉËØïÊó•Âøó‰∏≠Èó¥‰ª∂
    this.app.use((req: Request, res: Response, next) => {
      logger.debug(`üîç [Ë∑ØÁî±Ë∞ÉËØï] ${req.method} ${req.path} - Êü•ÊâæÂåπÈÖçÁöÑË∑ØÁî±`);
      if (req.path.startsWith('/agent/api/')) {
        logger.warn(`‚ö†Ô∏è [Ë∑ØÁî±Ë∞ÉËØï] Ê£ÄÊµãÂà∞ /agent/api/ Ë∑ØÂæÑËØ∑Ê±ÇÔºå‰ΩÜÂΩìÂâçÊ≤°ÊúâÂØπÂ∫îÁöÑË∑ØÁî±ÈÖçÁΩÆÔºÅ`);
        logger.warn(`‚ö†Ô∏è [Ë∑ØÁî±Ë∞ÉËØï] ËØ∑Ê±ÇËØ¶ÊÉÖ: ${req.method} ${req.path}`);
        logger.warn(`‚ö†Ô∏è [Ë∑ØÁî±Ë∞ÉËØï] Êü•ËØ¢ÂèÇÊï∞: ${JSON.stringify(req.query)}`);
      }
      next();
    });

    // ÂÅ•Â∫∑Ê£ÄÊü•Á´ØÁÇπ
    this.app.get('/health', (req: Request, res: Response) => {
      res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
      });
    });

    // AgentÁä∂ÊÄÅÁ´ØÁÇπ
    this.app.get('/agents', (req: Request, res: Response) => {
      const agents = AgentManager.listAgents();
      res.json(agents);
    });

    // AgentËØ¶ÊÉÖÁ´ØÁÇπ
    this.app.get('/agents/:did', (req: Request, res: Response) => {
      const { did } = req.params;
      
      // Êô∫ËÉΩDIDËß£Á†ÅÔºöËß£Á†Å‰∏ÄÊ¨°ÂêéÂ¶ÇÊûúÂåÖÂê´ %3AÔºåÂ∞±ÂÅúÊ≠¢Ëß£Á†Å
      let decodedDid = decodeURIComponent(did);
      if (decodedDid.includes('%3A')) {
        // ‰ΩøÁî®ÂåÖÂê´ %3A ÁöÑÊ†ºÂºèÔºåËøô‰∏éAgentÊ≥®ÂÜåÊó∂ÁöÑÊ†ºÂºè‰∏ÄËá¥
        logger.debug(`üîç AgentËØ¶ÊÉÖ - ÂéüÂßãDID: ${did}, Ëß£Á†ÅÂêé(ÂåÖÂê´%3A): ${decodedDid}`);
      } else {
        logger.debug(`üîç AgentËØ¶ÊÉÖ - ÂéüÂßãDID: ${did}, ÂÆåÂÖ®Ëß£Á†ÅÂêé: ${decodedDid}`);
      }
      
      const agent = AgentManager.getAgentByDid(decodedDid);
      
      if (!agent) {
        return res.status(404).json({ error: 'Agent not found' });
      }

      res.json(agent.toDict());
    });

    // Agent APIË∞ÉÁî®Á´ØÁÇπ
    this.app.all('/agents/:did/*', async (req: Request, res: Response) => {
      const { did } = req.params;
      const path = '/' + req.params[0];
      
      // Êô∫ËÉΩDIDËß£Á†ÅÔºöËß£Á†Å‰∏ÄÊ¨°ÂêéÂ¶ÇÊûúÂåÖÂê´ %3AÔºåÂ∞±ÂÅúÊ≠¢Ëß£Á†Å
      let decodedDid = decodeURIComponent(did);
      if (decodedDid.includes('%3A')) {
        // ‰ΩøÁî®ÂåÖÂê´ %3A ÁöÑÊ†ºÂºèÔºåËøô‰∏éAgentÊ≥®ÂÜåÊó∂ÁöÑÊ†ºÂºè‰∏ÄËá¥
        logger.debug(`üîç Agent APIË∞ÉÁî® - ÂéüÂßãDID: ${did}, Ëß£Á†ÅÂêé(ÂåÖÂê´%3A): ${decodedDid}`);
      } else {
        logger.debug(`üîç Agent APIË∞ÉÁî® - ÂéüÂßãDID: ${did}, ÂÆåÂÖ®Ëß£Á†ÅÂêé: ${decodedDid}`);
      }
      
      const agent = AgentManager.getAgentByDid(decodedDid);
      
      if (!agent) {
        return res.status(404).json({ error: 'Agent not found' });
      }

      try {
        const requestData = {
          type: 'api_call',
          path: path,
          method: req.method,
          headers: req.headers,
          body: req.body,
          query: req.query,
          req_did: (req as any).auth?.callerDid || 'anonymous'
        };

        const response = await agent.handleRequest((req as any).auth?.callerDid || 'anonymous', requestData, req);
        
        if (response && typeof response === 'object' && 'status' in response) {
          res.status(response.status);
          if (response.headers) {
            Object.entries(response.headers).forEach(([key, value]) => {
              res.setHeader(key, String(value));
            });
          }
          res.json(response.body);
        } else {
          res.json(response);
        }

      } catch (error) {
        logger.error(`Agent APIË∞ÉÁî®Â§±Ë¥•: ${did}${path}:`, error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });

    // Ê∑ªÂä† /agent/api/ Ë∑ØÂæÑÊîØÊåÅ - ‰øÆÂ§ç404ÈîôËØØ
    this.setupAgentApiRoutes();

    // Âä®ÊÄÅË∑ØÁî±Â§ÑÁêÜÔºàÂü∫‰∫éAgent prefixÔºâ
    this.app.all('*', async (req: Request, res: Response) => {
      const agent = AgentManager.findAgentByPathPrefix(req.path);
      
      if (!agent) {
        return res.status(404).json({ error: 'Route not found' });
      }

      try {
        const prefixLength = agent.prefix ? agent.prefix.length : 0;
        const requestData = {
          type: 'api_call',
          path: req.path.substring(prefixLength),
          method: req.method,
          headers: req.headers,
          body: req.body,
          query: req.query,
          req_did: (req as any).auth?.callerDid || 'anonymous'
        };

        const response = await agent.handleRequest((req as any).auth?.callerDid || 'anonymous', requestData, req);
        
        if (response && typeof response === 'object' && 'status' in response) {
          res.status(response.status);
          if (response.headers) {
            Object.entries(response.headers).forEach(([key, value]) => {
              res.setHeader(key, String(value));
            });
          }
          res.json(response.body);
        } else {
          res.json(response);
        }

      } catch (error) {
        logger.error(`Âä®ÊÄÅË∑ØÁî±Â§ÑÁêÜÂ§±Ë¥•: ${req.path}:`, error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
  }

  /**
   * ËÆæÁΩÆDIDÊúçÂä°Ë∑ØÁî±
   */
  private setupDIDRoutes(): void {
    const domainManager = new DomainManager();

    // DIDÊñáÊ°£Á´ØÁÇπ: /wba/user/{user_id}/did.json
    this.app.get('/wba/user/:userId/did.json', async (req: Request, res: Response) => {
      try {
        const { userId } = req.params;
        const host = req.hostname || 'localhost';
        const port = this.config.port || 9527;

        logger.debug(`DIDÊñáÊ°£ËØ∑Ê±Ç: userId=${userId}, host=${host}, port=${port}`);

        const result = await DIDServiceHandler.getDidDocument(userId, host, port);
        
        if (result.success) {
          res.json(result.data);
        } else {
          logger.warn(`DIDÊñáÊ°£Ëé∑ÂèñÂ§±Ë¥•: ${result.error}`);
          res.status(404).json({ error: result.error });
        }
      } catch (error) {
        logger.error(`DIDÊñáÊ°£Á´ØÁÇπÈîôËØØ:`, error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });

    // AgentÊèèËø∞Á´ØÁÇπ: /wba/user/{user_id}/ad.json
    this.app.get('/wba/user/:userId/ad.json', async (req: Request, res: Response) => {
      try {
        const { userId } = req.params;
        const host = req.hostname || 'localhost';
        const port = this.config.port || 9527;

        logger.debug(`AgentÊèèËø∞ËØ∑Ê±Ç: userId=${userId}, host=${host}, port=${port}`);

        const result = await DIDServiceHandler.getAgentDescription(userId, host, port);
        
        if (result.success) {
          res.json(result.data);
        } else {
          logger.warn(`AgentÊèèËø∞Ëé∑ÂèñÂ§±Ë¥•: ${result.error}`);
          res.status(404).json({ error: result.error });
        }
      } catch (error) {
        logger.error(`AgentÊèèËø∞Á´ØÁÇπÈîôËØØ:`, error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });

    // Agent YAMLÊñá‰ª∂Á´ØÁÇπ: /wba/user/{resp_did}/{yaml_file_name}.yaml
    this.app.get('/wba/user/:respDid/:yamlFileName.yaml', async (req: Request, res: Response) => {
      try {
        const { respDid, yamlFileName } = req.params;
        const host = req.hostname || 'localhost';
        const port = this.config.port || 9527;

        logger.debug(`Agent YAMLËØ∑Ê±Ç: respDid=${respDid}, yamlFileName=${yamlFileName}, host=${host}, port=${port}`);

        const result = await DIDServiceHandler.getAgentYamlFile(respDid, yamlFileName, host, port);
        
        if (result.success) {
          res.setHeader('Content-Type', 'application/x-yaml');
          res.send(result.data);
        } else {
          logger.warn(`Agent YAMLËé∑ÂèñÂ§±Ë¥•: ${result.error}`);
          res.status(404).json({ error: result.error });
        }
      } catch (error) {
        logger.error(`Agent YAMLÁ´ØÁÇπÈîôËØØ:`, error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });

    // Agent JSONÊñá‰ª∂Á´ØÁÇπ: /wba/user/{resp_did}/{json_file_name}.json
    this.app.get('/wba/user/:respDid/:jsonFileName.json', async (req: Request, res: Response) => {
      try {
        const { respDid, jsonFileName } = req.params;
        const host = req.hostname || 'localhost';
        const port = this.config.port || 9527;

        logger.debug(`Agent JSONËØ∑Ê±Ç: respDid=${respDid}, jsonFileName=${jsonFileName}, host=${host}, port=${port}`);

        const result = await DIDServiceHandler.getAgentJsonFile(respDid, jsonFileName, host, port);
        
        if (result.success) {
          res.json(result.data);
        } else {
          logger.warn(`Agent JSONËé∑ÂèñÂ§±Ë¥•: ${result.error}`);
          res.status(404).json({ error: result.error });
        }
      } catch (error) {
        logger.error(`Agent JSONÁ´ØÁÇπÈîôËØØ:`, error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });

    logger.info('DIDÊúçÂä°Ë∑ØÁî±Â∑≤Ê≥®ÂÜå');
  }

  /**
   * ËÆæÁΩÆAgent APIË∑ØÁî± - ‰øÆÂ§ç /agent/api/ Ë∑ØÂæÑ404ÈîôËØØ
   */
  private setupAgentApiRoutes(): void {
    // Agent APIÈÄöÁî®Ë∑ØÁî±: /agent/api/{did}/{subpath}
    this.app.all('/agent/api/:did/*', async (req: Request, res: Response) => {
      const { did } = req.params;
      const subpath = req.params[0] || '';
      const fullPath = '/' + subpath;
      
      logger.debug(`üîÑ Â§ÑÁêÜAgent APIËØ∑Ê±Ç: /agent/api/${did}${fullPath}`);
      
      // Êô∫ËÉΩDIDËß£Á†ÅÔºöËß£Á†Å‰∏ÄÊ¨°ÂêéÂ¶ÇÊûúÂåÖÂê´ %3AÔºåÂ∞±ÂÅúÊ≠¢Ëß£Á†Å
      let decodedDid = decodeURIComponent(did);
      
      // Â¶ÇÊûúËß£Á†ÅÂêéÂåÖÂê´ %3AÔºåËØ¥ÊòéËøôÊòØÊ≠£Á°ÆÁöÑÊ†ºÂºèÔºå‰∏çÈúÄË¶ÅËøõ‰∏ÄÊ≠•Ëß£Á†Å
      if (decodedDid.includes('%3A')) {
        // ‰ΩøÁî®ÂåÖÂê´ %3A ÁöÑÊ†ºÂºèÔºåËøô‰∏éAgentÊ≥®ÂÜåÊó∂ÁöÑÊ†ºÂºè‰∏ÄËá¥
        logger.debug(`üîç ÂéüÂßãDIDÂèÇÊï∞: ${did}`);
        logger.debug(`üîç Ëß£Á†ÅÂêéÁöÑDID (ÂåÖÂê´%3A): ${decodedDid}`);
      } else {
        // Â¶ÇÊûúËß£Á†ÅÂêé‰∏çÂåÖÂê´ %3AÔºå‰ΩøÁî®Ëß£Á†ÅÂêéÁöÑÁªìÊûú
        logger.debug(`üîç ÂéüÂßãDIDÂèÇÊï∞: ${did}`);
        logger.debug(`üîç ÂÆåÂÖ®Ëß£Á†ÅÂêéÁöÑDID: ${decodedDid}`);
      }
      
      // Ë∞ÉËØïÔºöÂàóÂá∫ÊâÄÊúâÂ∑≤Ê≥®ÂÜåÁöÑAgent DID
      const allAgents = AgentManager.getAllAgents();
      logger.debug(`üîç Â∑≤Ê≥®ÂÜåÁöÑAgentÊï∞Èáè: ${allAgents.length}`);
      for (const agent of allAgents) {
        logger.debug(`üîç Â∑≤Ê≥®ÂÜåAgent DID: ${agent.anpUser.id}`);
      }
      
      const agent = AgentManager.getAgentByDid(decodedDid);
      
      if (!agent) {
        logger.warn(`‚ùå AgentÊú™ÊâæÂà∞: ${decodedDid}`);
        return res.status(404).json({
          error: 'Agent not found',
          did: decodedDid,
          originalDid: did
        });
      }

      try {
        const callerDid = (req as any).auth?.callerDid || req.query.req_did || 'anonymous';
        
        const requestData = {
          type: 'api_call',
          path: fullPath,
          method: req.method,
          headers: req.headers,
          body: req.body,
          query: req.query,
          req_did: callerDid
        };

        logger.debug(`üì§ ÂèëÈÄÅËØ∑Ê±ÇÂà∞Agent: ${decodedDid}, Ë∑ØÂæÑ: ${fullPath}, Ë∞ÉÁî®ËÄÖ: ${callerDid}`);
        
        const response = await agent.handleRequest(callerDid, requestData, req);
        
        if (response && typeof response === 'object' && 'status' in response) {
          res.status(response.status);
          if (response.headers) {
            Object.entries(response.headers).forEach(([key, value]) => {
              res.setHeader(key, String(value));
            });
          }
          res.json(response.body);
        } else {
          res.json(response);
        }

        logger.debug(`‚úÖ Agent APIËØ∑Ê±ÇÂ§ÑÁêÜÊàêÂäü: ${decodedDid}${fullPath}`);

      } catch (error) {
        logger.error(`‚ùå Agent APIËØ∑Ê±ÇÂ§ÑÁêÜÂ§±Ë¥•: ${decodedDid}${fullPath}:`, error);
        res.status(500).json({
          error: 'Internal server error',
          message: error instanceof Error ? error.message : String(error)
        });
      }
    });

    // ÁâπÂÆöÁöÑaddÁ´ØÁÇπË∑ØÁî±: /agent/api/{did}/add
    this.app.all('/agent/api/:did/add', async (req: Request, res: Response) => {
      const { did } = req.params;
      
      logger.debug(`üîÑ Â§ÑÁêÜAgentËøûÊé•Ê∑ªÂä†ËØ∑Ê±Ç: /agent/api/${did}/add`);
      
      // Êô∫ËÉΩDIDËß£Á†ÅÔºöËß£Á†Å‰∏ÄÊ¨°ÂêéÂ¶ÇÊûúÂåÖÂê´ %3AÔºåÂ∞±ÂÅúÊ≠¢Ëß£Á†Å
      let decodedDid = decodeURIComponent(did);
      
      // Â¶ÇÊûúËß£Á†ÅÂêéÂåÖÂê´ %3AÔºåËØ¥ÊòéËøôÊòØÊ≠£Á°ÆÁöÑÊ†ºÂºèÔºå‰∏çÈúÄË¶ÅËøõ‰∏ÄÊ≠•Ëß£Á†Å
      if (decodedDid.includes('%3A')) {
        // ‰ΩøÁî®ÂåÖÂê´ %3A ÁöÑÊ†ºÂºèÔºåËøô‰∏éAgentÊ≥®ÂÜåÊó∂ÁöÑÊ†ºÂºè‰∏ÄËá¥
        logger.debug(`üîç AgentËøûÊé•Ê∑ªÂä† - ÂéüÂßãDID: ${did}, Ëß£Á†ÅÂêé(ÂåÖÂê´%3A): ${decodedDid}`);
      } else {
        // Â¶ÇÊûúËß£Á†ÅÂêé‰∏çÂåÖÂê´ %3AÔºå‰ΩøÁî®Ëß£Á†ÅÂêéÁöÑÁªìÊûú
        logger.debug(`üîç AgentËøûÊé•Ê∑ªÂä† - ÂéüÂßãDID: ${did}, ÂÆåÂÖ®Ëß£Á†ÅÂêé: ${decodedDid}`);
      }
      const agent = AgentManager.getAgentByDid(decodedDid);
      
      if (!agent) {
        logger.warn(`‚ùå AgentÊú™ÊâæÂà∞ (addËØ∑Ê±Ç): ${decodedDid}`);
        return res.status(404).json({
          error: 'Agent not found for add request',
          did: decodedDid,
          originalDid: did
        });
      }

      try {
        const callerDid = (req as any).auth?.callerDid || req.query.req_did || 'anonymous';
        const respDid = req.query.resp_did || decodedDid;
        
        const requestData = {
          type: 'agent_connect',
          action: 'add',
          method: req.method,
          headers: req.headers,
          body: req.body,
          query: req.query,
          req_did: callerDid,
          resp_did: respDid
        };

        logger.debug(`üì§ ÂèëÈÄÅËøûÊé•Ê∑ªÂä†ËØ∑Ê±ÇÂà∞Agent: ${decodedDid}, Ë∞ÉÁî®ËÄÖ: ${callerDid}, ÂìçÂ∫îËÄÖ: ${respDid}`);
        
        const response = await agent.handleRequest(callerDid, requestData, req);
        
        // ËøîÂõûÊàêÂäüÂìçÂ∫î
        res.json({
          success: true,
          action: 'add',
          req_did: callerDid,
          resp_did: respDid,
          data: response
        });

        logger.debug(`‚úÖ AgentËøûÊé•Ê∑ªÂä†ËØ∑Ê±ÇÂ§ÑÁêÜÊàêÂäü: ${decodedDid}`);

      } catch (error) {
        logger.error(`‚ùå AgentËøûÊé•Ê∑ªÂä†ËØ∑Ê±ÇÂ§ÑÁêÜÂ§±Ë¥•: ${decodedDid}:`, error);
        res.status(500).json({
          error: 'Agent connect add failed',
          message: error instanceof Error ? error.message : String(error)
        });
      }
    });

    logger.info('Agent APIË∑ØÁî±Â∑≤Ê≥®ÂÜå (/agent/api/)');
  }

  /**
   * Ê≥®ÂÜåAgent
   */
  public registerAgent(agent: Agent): void {
    // AgentÂ∑≤ÁªèÈÄöËøáAgentManager.createAgentÂàõÂª∫Âπ∂Ê≥®ÂÜåÔºåËøôÈáåÂè™ÊòØÊó•ÂøóËÆ∞ÂΩï
    logger.info(`AgentÊ≥®ÂÜåÂà∞ÊúçÂä°Âô®: ${agent.name} (${agent.anpUser.id})`);
  }

  /**
   * ÊâπÈáèÊ≥®ÂÜåAgent
   */
  public registerAgents(agents: Agent[]): void {
    agents.forEach(agent => this.registerAgent(agent));
  }

  /**
   * Ê≥®ÂÜåDIDÊñáÊ°£Âà∞ËÆ§ËØÅÈ™åËØÅÂô®
   * TODO: ÂÆûÁé∞DIDÊñáÊ°£Ê≥®ÂÜåÂäüËÉΩ
   */
  public registerDIDDocument(did: string, didDocument: any): void {
    // AuthVerifier ÁõÆÂâç‰∏çÊîØÊåÅÁõ¥Êé•Ê≥®ÂÜåDIDÊñáÊ°£
    // Ëøô‰∏™ÂäüËÉΩÈúÄË¶ÅÂú®Êú™Êù•ÁâàÊú¨‰∏≠ÂÆûÁé∞
    logger.info(`DIDÊñáÊ°£Ê≥®ÂÜåËØ∑Ê±Ç: ${did} (ÊöÇÊú™ÂÆûÁé∞)`);
  }

  /**
   * Ëé∑ÂèñExpressÂ∫îÁî®ÂÆû‰æã
   */
  public getExpressApp(): Application {
    return this.app;
  }

  /**
   * ÂêØÂä®ÊúçÂä°Âô®
   */
  public async start(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        const port = this.config.port!; // ‰ΩøÁî®ÈùûÁ©∫Êñ≠Ë®ÄÔºåÂõ†‰∏∫ÊûÑÈÄ†ÂáΩÊï∞‰∏≠Â∑≤ÁªèËÆæÁΩÆ‰∫ÜÈªòËÆ§ÂÄº
        const host = this.config.host!; // ‰ΩøÁî®ÈùûÁ©∫Êñ≠Ë®ÄÔºåÂõ†‰∏∫ÊûÑÈÄ†ÂáΩÊï∞‰∏≠Â∑≤ÁªèËÆæÁΩÆ‰∫ÜÈªòËÆ§ÂÄº
        
        this.server = this.app.listen(port, host, () => {
          logger.info(`üöÄ ANPÊúçÂä°Âô®ÂêØÂä®ÊàêÂäü: http://${host}:${port}`);
          resolve();
        });

        this.server.on('error', (error: any) => {
          logger.error('ÊúçÂä°Âô®ÂêØÂä®Â§±Ë¥•:', error);
          reject(error);
        });
      } catch (error) {
        logger.error('ÊúçÂä°Âô®ÂêØÂä®ÈîôËØØ:', error);
        reject(error);
      }
    });
  }

  /**
   * ÂÅúÊ≠¢ÊúçÂä°Âô®
   */
  public async stop(): Promise<void> {
    return new Promise((resolve) => {
      if (this.server) {
        this.server.close(() => {
          logger.info('ANPÊúçÂä°Âô®Â∑≤ÂÅúÊ≠¢');
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  /**
   * ‰ºòÈõÖÂÖ≥Èó≠
   */
  public async gracefulShutdown(): Promise<void> {
    logger.info('ÂºÄÂßã‰ºòÈõÖÂÖ≥Èó≠ÊúçÂä°Âô®...');
    
    // ÂÅúÊ≠¢Êé•ÂèóÊñ∞ËøûÊé•
    await this.stop();
    
    // ÁªôÊ≠£Âú®Â§ÑÁêÜÁöÑËØ∑Ê±Ç‰∏Ä‰∫õÊó∂Èó¥ÂÆåÊàê
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    logger.info('ÊúçÂä°Âô®‰ºòÈõÖÂÖ≥Èó≠ÂÆåÊàê');
  }

  /**
   * Ëé∑ÂèñÊúçÂä°Âô®ÁªüËÆ°‰ø°ÊÅØ
   */
  public getStats(): {
    config: ServerConfig;
    agents: number;
    uptime: number;
  } {
    return {
      config: this.config,
      agents: AgentManager.getAllAgents().length,
      uptime: process.uptime()
    };
  }
}
