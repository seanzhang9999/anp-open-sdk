# 通用记忆装饰器技术设计

## 概述

本文档详细描述了将ANP记忆系统从`@local_method`装饰器中解耦，设计成通用记忆装饰器的完整实现方案。

## 架构设计

### 1. 核心组件

```
通用记忆装饰器
├── MemoryContext (上下文管理器)
├── MemoryDecorator (通用装饰器)  
├── MemoryConfig (配置管理)
└── Integration (集成工具)
```

### 2. 文件结构

```
anp-open-sdk-python/anp_runtime/decorators/
├── __init__.py
├── memory_decorator.py (新增 - 通用记忆装饰器)
└── memory_integration.py (新增 - 集成工具)
```

## 详细实现

### 1. 通用记忆装饰器 (memory_decorator.py)

```python
"""
通用记忆装饰器模块

提供解耦的记忆功能，可以应用到任何函数/方法上
"""

import asyncio
import functools
import inspect
import threading
import time
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional, Union

from anp_runtime.local_service.memory import get_memory_collector, MemoryOptions
from anp_runtime.local_service.memory.memory_models import MemoryType
from anp_runtime.local_service.memory.memory_manager import get_memory_manager


class MemoryContext:
    """记忆上下文管理器"""
    
    def __init__(self):
        self._context_stack = []
        self._lock = threading.RLock()
    
    def push_context(self, context: Dict[str, Any]):
        """推入上下文"""
        with self._lock:
            self._context_stack.append(context)
    
    def pop_context(self) -> Optional[Dict[str, Any]]:
        """弹出上下文"""
        with self._lock:
            if self._context_stack:
                return self._context_stack.pop()
        return None
    
    def get_current_context(self) -> Dict[str, Any]:
        """获取当前上下文"""
        with self._lock:
            if self._context_stack:
                return self._context_stack[-1].copy()
        return {}


# 全局上下文管理器
_memory_context = MemoryContext()


class MemoryDecoratorConfig:
    """记忆装饰器配置"""
    
    def __init__(
        self,
        enabled: bool = True,
        tags: Optional[List[str]] = None,
        keywords: Optional[List[str]] = None,
        collect_input: bool = True,
        collect_output: bool = True,
        collect_errors: bool = True,
        session_id: Optional[str] = None,
        agent_did: Optional[str] = None,
        agent_name: Optional[str] = None,
        method_name: Optional[str] = None,
        method_key: Optional[str] = None,
        auto_context: bool = True  # 是否自动获取上下文
    ):
        self.enabled = enabled
        self.tags = tags or []
        self.keywords = keywords or []
        self.collect_input = collect_input
        self.collect_output = collect_output
        self.collect_errors = collect_errors
        self.session_id = session_id
        self.agent_did = agent_did
        self.agent_name = agent_name
        self.method_name = method_name
        self.method_key = method_key
        self.auto_context = auto_context
    
    @classmethod
    def from_dict(cls, config: Dict[str, Any]) -> 'MemoryDecoratorConfig':
        """从字典创建配置"""
        return cls(**config)
    
    @classmethod
    def from_memory_options(cls, options: MemoryOptions) -> 'MemoryDecoratorConfig':
        """从MemoryOptions创建配置"""
        return cls(
            enabled=options.enabled,
            tags=options.tags,
            keywords=options.keywords,
            collect_input=options.collect_input,
            collect_output=options.collect_output,
            collect_errors=options.collect_errors,
            session_id=options.session_id
        )


def with_memory(
    enabled: bool = True,
    tags: Optional[List[str]] = None,
    keywords: Optional[List[str]] = None,
    collect_input: bool = True,
    collect_output: bool = True,
    collect_errors: bool = True,
    session_id: Optional[str] = None,
    agent_did: Optional[str] = None,
    agent_name: Optional[str] = None,
    method_name: Optional[str] = None,
    method_key: Optional[str] = None,
    auto_context: bool = True,
    memory_config: Optional[Union[Dict, MemoryOptions, MemoryDecoratorConfig]] = None
) -> Callable:
    """
    通用记忆装饰器
    
    Args:
        enabled: 是否启用记忆收集
        tags: 记忆标签
        keywords: 记忆关键词
        collect_input: 是否收集输入参数
        collect_output: 是否收集输出结果
        collect_errors: 是否收集错误信息
        session_id: 会话ID
        agent_did: Agent DID
        agent_name: Agent名称
        method_name: 方法名称
        method_key: 方法键值
        auto_context: 是否自动获取上下文
        memory_config: 记忆配置对象（优先级最高）
    
    Returns:
        装饰器函数
    
    Examples:
        # 基本用法
        @with_memory(enabled=True, tags=["test"])
        def my_function():
            pass
        
        # 使用配置对象
        config = MemoryDecoratorConfig(tags=["api"], collect_errors=True)
        @with_memory(memory_config=config)
        async def api_handler():
            pass
        
        # 在类方法中使用
        class MyAgent:
            @with_memory(tags=["method"], auto_context=True)
            def my_method(self):
                pass
    """
    
    def decorator(func: Callable) -> Callable:
        # 解析配置
        if memory_config:
            if isinstance(memory_config, dict):
                config = MemoryDecoratorConfig.from_dict(memory_config)
            elif isinstance(memory_config, MemoryOptions):
                config = MemoryDecoratorConfig.from_memory_options(memory_config)
            elif isinstance(memory_config, MemoryDecoratorConfig):
                config = memory_config
            else:
                config = MemoryDecoratorConfig()
        else:
            config = MemoryDecoratorConfig(
                enabled=enabled,
                tags=tags,
                keywords=keywords,
                collect_input=collect_input,
                collect_output=collect_output,
                collect_errors=collect_errors,
                session_id=session_id,
                agent_did=agent_did,
                agent_name=agent_name,
                method_name=method_name,
                method_key=method_key,
                auto_context=auto_context
            )
        
        # 如果未启用，直接返回原函数
        if not config.enabled:
            return func
        
        # 提取方法信息
        actual_method_name = config.method_name or func.__name__
        actual_method_key = config.method_key or f"{func.__module__}::{func.__name__}"
        
        # 判断是否为异步函数
        is_async = inspect.iscoroutinefunction(func)
        
        if is_async:
            @functools.wraps(func)
            async def async_wrapper(*args, **kwargs):
                return await _execute_with_memory(
                    func, config, actual_method_name, actual_method_key,
                    args, kwargs, is_async=True
                )
            return async_wrapper
        else:
            @functools.wraps(func)
            def sync_wrapper(*args, **kwargs):
                # 对于同步函数，需要特殊处理异步记忆收集
                return _execute_sync_with_memory(
                    func, config, actual_method_name, actual_method_key,
                    args, kwargs
                )
            return sync_wrapper
    
    return decorator


async def _execute_with_memory(
    func: Callable,
    config: MemoryDecoratorConfig,
    method_name: str,
    method_key: str,
    args: tuple,
    kwargs: dict,
    is_async: bool = True
) -> Any:
    """在记忆收集的上下文中执行函数"""
    
    # 获取记忆收集器
    try:
        collector = get_memory_collector()
    except Exception as e:
        # 如果记忆系统不可用，直接执行原函数
        print(f"记忆系统不可用: {e}")
        if is_async:
            return await func(*args, **kwargs)
        else:
            return func(*args, **kwargs)
    
    # 解析上下文信息
    context = _resolve_context(config, args, kwargs)
    agent_did = context.get('agent_did', 'unknown')
    agent_name = context.get('agent_name', 'unknown')
    session_id = context.get('session_id')
    
    # 创建记忆收集装饰器
    memory_decorator = collector.create_collection_decorator(
        method_name=method_name,
        method_key=method_key,
        agent_did=agent_did,
        agent_name=agent_name,
        session_id=session_id
    )
    
    # 应用记忆收集装饰器
    wrapped_func = memory_decorator(func)
    
    # 执行函数
    if is_async:
        return await wrapped_func(*args, **kwargs)
    else:
        return wrapped_func(*args, **kwargs)


def _execute_sync_with_memory(
    func: Callable,
    config: MemoryDecoratorConfig,
    method_name: str,
    method_key: str,
    args: tuple,
    kwargs: dict
) -> Any:
    """为同步函数执行记忆收集"""
    
    try:
        # 尝试在现有事件循环中执行
        loop = asyncio.get_event_loop()
        if loop.is_running():
            # 如果循环正在运行，创建任务
            task = loop.create_task(_execute_with_memory(
                func, config, method_name, method_key, args, kwargs, is_async=False
            ))
            # 等待任务完成（这可能不是最佳方案，需要根据实际情况调整）
            return func(*args, **kwargs)
        else:
            # 如果循环没有运行，直接运行
            return loop.run_until_complete(_execute_with_memory(
                func, config, method_name, method_key, args, kwargs, is_async=False
            ))
    except RuntimeError:
        # 没有事件循环，创建新的
        return asyncio.run(_execute_with_memory(
            func, config, method_name, method_key, args, kwargs, is_async=False
        ))


def _resolve_context(
    config: MemoryDecoratorConfig, 
    args: tuple, 
    kwargs: dict
) -> Dict[str, Any]:
    """解析执行上下文"""
    
    context = {}
    
    # 优先使用配置中的显式值
    if config.agent_did:
        context['agent_did'] = config.agent_did
    if config.agent_name:
        context['agent_name'] = config.agent_name
    if config.session_id:
        context['session_id'] = config.session_id
    
    # 如果启用自动上下文，尝试从多个源获取
    if config.auto_context:
        # 1. 从全局上下文获取
        global_context = _memory_context.get_current_context()
        for key in ['agent_did', 'agent_name', 'session_id']:
            if key not in context and key in global_context:
                context[key] = global_context[key]
        
        # 2. 从函数参数中推断（如果是类方法）
        if args and hasattr(args[0], '__class__'):
            instance = args[0]
            
            # 尝试从instance获取agent信息
            if hasattr(instance, '_agent'):
                agent = instance._agent
                if hasattr(agent, 'user') and hasattr(agent.user, 'did'):
                    context.setdefault('agent_did', agent.user.did)
                if hasattr(agent, 'name'):
                    context.setdefault('agent_name', agent.name)
            
            # 尝试从instance获取其他信息
            for attr in ['agent_did', 'agent_name', 'session_id']:
                if hasattr(instance, attr):
                    context.setdefault(attr, getattr(instance, attr))
    
    # 提供默认值
    context.setdefault('agent_did', 'unknown')
    context.setdefault('agent_name', 'unknown')
    
    return context


# 上下文管理函数
def set_memory_context(**kwargs):
    """设置全局记忆上下文"""
    _memory_context.push_context(kwargs)


def clear_memory_context():
    """清除当前记忆上下文"""
    _memory_context.pop_context()


# 便捷创建函数
def create_memory_decorator(
    memory_config: Union[bool, Dict, MemoryOptions, MemoryDecoratorConfig]
) -> Callable:
    """根据配置创建记忆装饰器"""
    
    if isinstance(memory_config, bool):
        if memory_config:
            return with_memory(enabled=True)
        else:
            return lambda func: func  # 无操作装饰器
    
    elif isinstance(memory_config, dict):
        return with_memory(memory_config=memory_config)
    
    elif isinstance(memory_config, (MemoryOptions, MemoryDecoratorConfig)):
        return with_memory(memory_config=memory_config)
    
    else:
        return lambda func: func  # 默认无操作


# 类型简化别名
memory = with_memory  # 简化别名
```

### 2. 集成工具模块 (memory_integration.py)

```python
"""
记忆装饰器集成工具

提供与现有装饰器系统的集成功能
"""

import functools
from typing import Any, Callable, Dict, List, Optional, Union

from .memory_decorator import create_memory_decorator, MemoryDecoratorConfig, MemoryOptions


def integrate_memory_to_decorator(original_decorator: Callable) -> Callable:
    """
    为现有装饰器添加记忆功能支持
    
    Args:
        original_decorator: 原始装饰器函数
        
    Returns:
        增强后的装饰器函数
        
    Example:
        # 增强现有装饰器
        enhanced_api = integrate_memory_to_decorator(class_api)
        
        @enhanced_api("/test", memory=True)
        async def test_api(self):
            pass
    """
    
    @functools.wraps(original_decorator)
    def enhanced_decorator(*dec_args, memory=None, **dec_kwargs):
        """增强后的装饰器"""
        
        def decorator(func):
            # 首先应用原始装饰器
            enhanced_func = original_decorator(*dec_args, **dec_kwargs)(func)
            
            # 如果有记忆配置，再应用记忆装饰器
            if memory:
                memory_decorator = create_memory_decorator(memory)
                enhanced_func = memory_decorator(enhanced_func)
            
            return enhanced_func
        
        return decorator
    
    return enhanced_decorator


class MemoryMixin:
    """记忆功能Mixin类，为类提供记忆相关方法"""
    
    def set_memory_context(self, **kwargs):
        """为当前实例设置记忆上下文"""
        from .memory_decorator import set_memory_context
        
        # 自动注入实例相关信息
        if hasattr(self, '_agent'):
            kwargs.setdefault('agent_did', getattr(self._agent.user, 'did', 'unknown'))
            kwargs.setdefault('agent_name', getattr(self._agent, 'name', 'unknown'))
        
        set_memory_context(**kwargs)
    
    def get_memory_recommendations(
        self, 
        method_name: str, 
        max_results: int = 5
    ) -> List[Any]:
        """获取方法的记忆推荐"""
        try:
            from anp_runtime.local_service.memory import get_memory_recommender
            
            recommender = get_memory_recommender()
            
            # 获取agent信息
            agent_did = 'unknown'
            if hasattr(self, '_agent') and hasattr(self._agent, 'user'):
                agent_did = self._agent.user.did
            
            import asyncio
            return asyncio.run(recommender.recommend_for_method_call(
                method_name=method_name,
                method_key=f"{self.__class__.__module__}::{method_name}",
                agent_did=agent_did,
                max_recommendations=max_results
            ))
        except Exception as e:
            print(f"获取记忆推荐失败: {e}")
            return []
    
    def search_memories(
        self, 
        keywords: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        limit: int = 10
    ) -> List[Any]:
        """搜索相关记忆"""
        try:
            from anp_runtime.local_service.memory import get_memory_manager
            
            manager = get_memory_manager()
            
            import asyncio
            return asyncio.run(manager.search_memories(
                keywords=keywords,
                tags=tags,
                limit=limit
            ))
        except Exception as e:
            print(f"搜索记忆失败: {e}")
            return []


# 装饰器工厂函数
def memory_enabled(
    tags: Optional[List[str]] = None,
    keywords: Optional[List[str]] = None,
    session_id: Optional[str] = None,
    collect_errors: bool = True
) -> MemoryDecoratorConfig:
    """创建启用记忆的配置"""
    return MemoryDecoratorConfig(
        enabled=True,
        tags=tags,
        keywords=keywords,
        session_id=session_id,
        collect_errors=collect_errors
    )


def memory_disabled() -> MemoryDecoratorConfig:
    """创建禁用记忆的配置"""
    return MemoryDecoratorConfig(enabled=False)


def memory_for_testing(
    collect_input: bool = True,
    collect_output: bool = True
) -> MemoryDecoratorConfig:
    """创建用于测试的记忆配置"""
    return MemoryDecoratorConfig(
        enabled=True,
        tags=["testing"],
        collect_input=collect_input,
        collect_output=collect_output,
        collect_errors=True
    )
```

### 3. 现有装饰器增强示例

#### 增强 agent_decorator.py

```python
# 在 anp_runtime/agent_decorator.py 中添加记忆支持

from anp_runtime.decorators.memory_integration import create_memory_decorator

def class_api(
    path, 
    methods=None, 
    description=None,
    parameters=None, 
    returns=None, 
    auto_wrap=True,
    # 新增记忆参数
    memory: Union[bool, dict, MemoryOptions, MemoryDecoratorConfig] = None
):
    """类方法API装饰器（增强记忆支持）"""
    def decorator(method):
        # 原有逻辑
        setattr(method, '_api_path', path)
        setattr(method, '_is_class_method', True)
        
        # 设置能力元数据
        capability_meta = {
            'name': method.__name__,
            'description': description or method.__doc__ or f"API: {path}",
            'publish_as': "expose_api",
            'parameters': parameters or {},
            'returns': returns or "object"
        }
        setattr(method, '_capability_meta', capability_meta)
        
        # 新增：记忆功能集成
        if memory:
            memory_decorator = create_memory_decorator(memory)
            method = memory_decorator(method)
        
        # 原有的包装逻辑...
        if auto_wrap:
            # 现有的 wrap_business_handler 逻辑
            pass
            
        return method
    return decorator


def class_message_handler(
    msg_type, 
    description=None, 
    auto_wrap=True,
    # 新增记忆参数
    memory: Union[bool, dict, MemoryOptions, MemoryDecoratorConfig] = None
):
    """类方法消息处理器装饰器（增强记忆支持）"""
    def decorator(method):
        # 原有逻辑
        setattr(method, '_message_type', msg_type)
        
        # 设置能力元数据
        if description:
            capability_meta = {
                'name': method.__name__,
                'description': description or method.__doc__ or f"消息处理器: {msg_type}",
                'publish_as': "message_handler"
            }
            setattr(method, '_capability_meta', capability_meta)
        
        # 新增：记忆功能集成
        if memory:
            memory_decorator = create_memory_decorator(memory)
            method = memory_decorator(method)
        
        # 原有的包装逻辑...
        return method
    return decorator


# 增强 agent_class 装饰器，添加记忆支持
from anp_runtime.decorators.memory_integration import MemoryMixin

def agent_class(
    name: str,
    description: str = "",
    version: str = "1.0.0",
    tags: List[str] = None,
    did: str = None,
    shared: bool = False,
    prefix: str = None,
    primary_agent: bool = False,
    # 新增：为整个类启用记忆功能
    enable_memory: bool = False,
    memory_tags: List[str] = None
):
    """Agent 类装饰器（增强记忆支持）"""
    def decorator(cls):
        # 如果启用记忆，添加MemoryMixin
        if enable_memory:
            # 动态添加MemoryMixin到基类
            if MemoryMixin not in cls.__bases__:
                cls.__bases__ = cls.__bases__ + (MemoryMixin,)
        
        # 原有的装饰器逻辑...
        original_init = cls.__init__
        
        @functools.wraps(original_init)
        def init_wrapper(self, *args, **kwargs):
            original_init(self, *args, **kwargs)
            self._initialize_agent()
            
            # 如果启用记忆，设置默认上下文
            if enable_memory:
                self.set_memory_context(
                    agent_did=self._agent.user.did if hasattr(self, '_agent') else 'unknown',
                    agent_name=name,
                    tags=memory_tags or []
                )
        
        cls.__init__ = init_wrapper
        
        # 其余原有逻辑...
        return cls
    
    return decorator
```

## 使用示例

### 1. 基础使用

```python
from anp_runtime.decorators.memory_decorator import with_memory, memory_enabled

# 简单启用记忆
@with_memory(enabled=True, tags=["test"])
def simple_function(x, y):
    return x + y

# 使用配置对象
@with_memory(memory_config=memory_enabled(tags=["math"], keywords=["add"]))
async def async_function(a, b):
    return a + b

# 完全配置
@with_memory(
    enabled=True,
    tags=["api", "calculation"],
    keywords=["math", "compute"],
    collect_input=True,
    collect_output=True,
    collect_errors=True,
    session_id="calc_session_001"
)
def advanced_function(data):
    return process_data(data)
```

### 2. 与现有装饰器结合

```python
from anp_runtime.decorators.memory_integration import memory_enabled, memory_for_testing

@agent_class(
    name="智能计算器",
    did="did:wba:localhost%3A9527:wba:user:27c0b1d11180f973",
    enable_memory=True,  # 为整个类启用记忆
    memory_tags=["calculator", "math"]
)
class SmartCalculatorAgent:
    
    @class_api(
        "/calculate", 
        description="执行数学计算",
        memory=memory_enabled(
            tags=["calculation"],
            keywords=["math", "compute"],
            session_id="calc_session"
        )
    )
    async def calculate_api(self, expression: str, precision: int = 2):
        result = eval(expression)  # 简化示例
        return {"result": round(result, precision)}
    
    @class_message_handler(
        "math_question",
        memory=memory_for_testing()  # 使用测试配置
    )
    async def handle_math_question(self, question: str):
        # 获取历史推荐
        recommendations = self.get_memory_recommendations("handle_math_question")
        print(f"找到 {len(recommendations)} 个相关记忆")
        
        return {"answer": "处理中..."}
    
    # 纯函数也可以使用记忆
    @with_memory(tags=["validation"], auto_context=True)
    def validate_expression(self, expr: str) -> bool:
        try:
            compile(expr, '<string>', 'eval')
            return True
        except SyntaxError:
            return False
```

### 3. 上下文管理

```python
from anp_runtime.decorators.memory_decorator import set_memory_context, clear_memory_context

# 设置全局上下文
set_memory_context(
    agent_did="did:wba:example",
    agent_name="TestAgent",
    session_id="session_123"
)

@with_memory(auto_context=True)  # 自动使用上下文
def context_aware_function():
    pass

# 清除上下文
clear_memory_context()
```

### 4. 独立使用（不依赖Agent）

```python
# 在普通Python应用中使用
@with_memory(
    agent_did="standalone_app",
    agent_name="DataProcessor",
    tags=["data_processing"],
    session_id="batch_001"
)
def process_batch_data(data_list):
    results = []
    for item in data_list:
        processed = complex_processing(item)
        results.append(processed)
    return results

# 异步版本
@with_memory(
    agent_did="async_processor", 
    agent_name="AsyncProcessor",
    tags=["async", "processing"]
)
async def async_process_data(data):
    await asyncio.sleep(0.1)  # 模拟异步操作
    return {"processed": data * 2}
```

## 迁移指南

### 从 @local_method 迁移

```python
# 旧方式
@local_method("计算函数", memory=True)
def old_calculate(a, b):
    return a + b

# 新方式（完全兼容）
@with_memory(enabled=True, method_name="计算函数")
def new_calculate(a, b):
    return a + b

# 或使用更丰富的配置
@with_memory(
    enabled=True,
    tags=["calculation"],
    keywords=["math"],
    agent_did="calculator_agent",
    agent_name="Calculator"
)
def enhanced_calculate(a, b):
    return a + b
```

### 批量迁移工具

```python
def migrate_local_method_to_memory(
    method_name: str,
    old_memory_config: dict
) -> MemoryDecoratorConfig:
    """将旧的@local_method记忆配置转换为新格式"""
    
    return MemoryDecoratorConfig(
        enabled=old_memory_config.get('enabled', True),
        tags=old_memory_config.get('memory_tags', []),
        keywords=old_memory_config.get('memory_keywords', []),
        collect_input=old_memory_config.get('collect_input', True),
        collect_output=old_memory_config.get('collect_output', True),
        collect_errors=old_memory_config.get('collect_errors', True),
        session_id=old_memory_config.get('session_id'),
        method_name=method_name,
        auto_context=True
    )
```

## 性能优化

### 1. 延迟加载

```python
# 记忆系统模块采用延迟加载，避免启动时性能影响
def _get_memory_collector():
    global _memory_collector_cache
    if _memory_collector_cache is None:
        try:
            from anp_runtime.local_service.memory import get_memory_collector
            _memory_collector_cache = get_memory_collector()
        except ImportError:
            _memory_collector_cache = None
    return _memory_collector_cache
```

### 2. 配置缓存

```python
# 缓存解析后的配置，避免重复解析
_config_cache = {}

def _get_cached_config(config_key: str, config_factory: Callable):
    if config_key not in _config_cache:
        _config_cache[config_key] = config_factory()
    return _config_cache[config_key]
```

### 3. 异步优化

```python
# 对于同步函数，记忆收集在后台异步进行，不阻塞主流程
async def _background_memory_collection(memory_data):
    try:
        collector = get_memory_collector()
        await collector.collect_manual_memory(**memory_data)
    except Exception as e:
        # 记忆收集失败不影响主业务逻辑
        logger.debug(f"后台记忆收集失败: {e}")
```

## 扩展性设计

### 1. 插件化记忆处理器

```python
class MemoryProcessor:
    """记忆处理器接口"""
    
    def process_input(self, input_data: Any) -> Any:
        """处理输入数据"""
        return input_data
    
    def process_output(self, output_data: Any) -> Any:
        """处理输出数据"""
        return output_data
    
    def process_error(self, error: Exception) -> dict:
        """处理错误信息"""
        return {"error_type": type(error).__name__, "message": str(error)}

# 注册自定义处理器
def register_memory_processor(processor: MemoryProcessor):
    """注册记忆处理器"""
    pass
```

### 2. 记忆策略配置

```python
class MemoryStrategy:
    """记忆策略"""
    
    def should_collect_input(self, func, args, kwargs) -> bool:
        """判断是否应该收集输入"""
        return True
    
    def should_collect_output(self, func, result) -> bool:
        """判断是否应该收集输出"""
        return True
    
    def get_memory_tags(self, func, context) -> List[str]:
        """动态生成记忆标签"""
        return []
```

## 测试策略

### 1. 单元测试

```python
import pytest
from anp_runtime.decorators.memory_decorator import with_memory, MemoryDecoratorConfig

def test_memory_decorator_basic():
    @with_memory(enabled=True, tags=["test"])
    def test_func(x, y):
        return x + y
    
    result = test_func(1, 2)
    assert result == 3

@pytest.mark.asyncio
async def test_async_memory_decorator():
    @with_memory(enabled=True, collect_errors=True)
    async def async_test_func(x):
        if x < 0:
            raise ValueError("负数")
        return x * 2
    
    result = await async_test_func(5)
    assert result == 10
    
    with pytest.raises(ValueError):
        await async_test_func(-1)
```

### 2. 集成测试

```python
def test_agent_memory_integration():
    @agent_class(name="TestAgent", enable_memory=True)
    class TestAgent:
        @class_api("/test", memory=True)
        async def test_api(self, data):
            return {"processed": data}
    
    agent = TestAgent()
    # 测试API调用会被记录
    # 测试记忆推荐功能
    # 测试记忆搜索功能
```

## 总结

通用记忆装饰器设计实现了以下目标：

1. **完全解耦**: 记忆功能不再依赖特定装饰器
2. **向后兼容**: 现有代码无需修改
3. **功能完整**: 保留所有高级记忆功能
4. **易于集成**: 任何装饰器都可轻松添加记忆支持
5. **性能优化**: 延迟加载和异步处理
6. **扩展性强**: 支持插件化和策略模式

这个设计让记忆系统真正成为ANP框架的通用基础设施，为所有类型的方法和函数提供智能记忆能力。